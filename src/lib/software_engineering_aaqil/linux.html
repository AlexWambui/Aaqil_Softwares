<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
		/>
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
	    <link rel="stylesheet" href="../assets/styles/bootstrap.min.css">
	    <link rel="stylesheet" href="../assets/styles/icomoon.css">
	    <link rel="stylesheet" href="../assets/styles/prism.css">
	    <link rel="stylesheet" href="../assets/styles/main.css">
	    <script src="../assets/js/jquery.min.js"></script>
	    <script src="../assets/js/popper.min.js"></script>
	    <script src="../assets/js/bootstrap.min.js"></script>
		<title>Linux</title>
	</head>
	<body>
		<section>
			<aside>
				<div class="nav_icons">
					<a href="index.html"><span class="icon-home"></span></a>
					<span class="icon-close"></span>
				</div>
				<div class="nav_heading">
					<h1>Linux</h1>
				</div>
				<div class="nav_body">
					<ul>
						<li><a href="#introduction">Introduction</a></li>
						<li><a href="#architecture">Architecture</a></li>
						<li><a href="#features">Features</a></li>
						<li><a href="#shell">Shell</a></li>
						<li><a href="#file_system_organization">File System Organization</a></li>
						<li><a href="#navigation">Navigation</a></li>
						<li><a href="#manipulating_files">Manipulating Files</a></li>
						<li><a href="#permissions">Permissions</a></li>
						<li><a href="#shell_scripting">Shell Scripting</a></li>
						<li><a href="#command_line_editors">Command line editors</a></li>
						<li><a href="#tips">Tips</a></li>
						<li><a href="#links">Links</a></li>
					</ul>
				</div>
			</aside>
			<main class="main_content">
				<section class="container" id="introduction">
					<h1 class="_h1">Introduction</h1>
					<div class="container">
						<p>Linux is the best known and most used open-source operating system.</p>
						<p>Linux is a multi-tasking and multi-user operating system.</p>
						<p>Linux was originally developed for personal computers but due to its fantastic features and robustness, it became a leading OS on servers and mainframe computers.</p>
						<p>As Linux is an open-source version of Unix, Linux kernel code is freely available to download and modify as per your business requirement and create your own operating system.</p>
						<p>The biggest power of linux is how easy it is to use.</p>
					</div>
				</section>

				<section class="container" id="architecture">
					<h1 class="_h1">Architecture</h1>
					<div class="container">
						<p>The architecture of linux can be divided into four levels of functionality:</p>
						<ul>
							<li>Hardware - combination of all peripherals associated with the system. eg. RAM, CPU, Hard disk etc.</li>
							<li>Kernel - the core part of OS and manages the CPU, memory and peripheral devices. It is the lowest level of the OS. It's responsible for all major activities of the OS. Written in C.</li>
							<li>Shell - acts as the user interface, interpreting user commands and starting an application. Users typically interact with a LInux shell using a terminal emulator, however, direct operation via serial hardware connections or networking session, are common for server systems.</li>
							<li>System Utitlites - built using system libraries and enable administrators to administer the sytem, manage processes, navigate on the file sytem, execute other applications, configure the network, etc.</li>
						</ul>

						<h2 class="_h2">Components of Linux OS</h2>
						<p>Linux OS is a collection of a number of components:</p>
						<ul>
							<li>Boot loader - program that loads the Linux kernel into the computer's main memory, by being executed by the computer when it is turned on and after the firmware initialization is performed.</li>
							<li>Kernel - is the core part of the OS and manages the CPU, memory and peripheral devices.</li>
							<li>Daemons - are background services that either startup during boot, or after you log into the desktop.</li>
							<li>Shell - command processor that allows you to control the computer via command typed into a text interface.</li>
							<li>System libraries - are special programs that help in accessing the kernel's features. Programmers have developed a standard library of procedures to communicate with the kernel.</li>
							<li>Graphic Server - is a sub-sytem that displays the graphics on your monitor. It is commonly referred to as the X server or just "X".</li>
							<li>System tools - Linux OS has a set of utility tools which are usually simple commands. It is a software which GNU project has written and published under their open source license so that software is freely available to everyone.</li>
						</ul>
					</div>
				</section>

				<section class="container" id="features">
					<h1 class="_h1">Features of Linux</h1>
					<div class="container">
						<p>Some features of Linux include:</p>
						<ul>
							<li>Multi-user - multiple users can access system resources at the same time.</li>
							<li>Multi-tasking - multiple jobs can run at the same time.</li>
							<li>Multi-programming - this means multiple applications can run at the same time.</li>
							<li>Portable - all programs can run on different system in the same functionality.</li>
							<li>Communication - Linux provide electronic mail. The communication can be within the network of single computers or between two or more such computer networks.</li>
							<li>Hierachical file systems - Linux has the hierachical file syste. Starts from / (root) directory.</li>
							<li>Shell - provides an interface to the user to run their programs.</li>
							<li>Security - Linux provides high security. Users passwords are strictly managed. In linux there's no need for other anit-malware applications because itself provides high security.</li>
						</ul>
					</div>
				</section>

				<section class="container" id="shell">
					<h1 class="_h1">Shell</h1>
					<div class="container">
						<p>Most of Unix systems are managed by using Shell.</p>
						<p>the shell is a program that takes commands from the keyboard and gives them to the operating system to perform.</p>
						<p>On most Linux systems a program called bash (which stands for Bourne Again SHell, an enhanced version of the original Unix shell program, sh, written by Steve Bourne) acts as the shell program. Besides bash, there are other shell programs available for Linux systems. These include: ksh, tcsh and zsh.</p>
						<p>Just as you need to know a minimum number of words to have a discussion in a language, you need to know a minimum number of commands to be able to easily interact with a system.</p>
						<p>To learn or remind yourself about how to use a command, use <code>man command</code>.</p>
						<p>You can also use whatis to find a short description of what the command does. eg. <code>whatis cal</code>.</p>
						<p>You can find commands to use by giving the system a pointer of what command you want to use. For example <code>apropos time</code></p>

						<h2 class="_h2">shell interpretation</h2>
						<p>Take an example of a command such as ls, in the terminal this would appear as:</p>
						<p class="command">root@hp:~$ ls</p>
						<p>root - represents the name of the user. It tells you who you are.</p>
						<p>@hp - represents the name of the computer you're logged into. At times you might be using ssh to remotely work with another computer so this help know exactlly which computer you're working with.</p>
						<p>~ - is an abbreviation for your home directory.</p>
						<p>$ - indicates you're logged in as a standard user meaning you have regular privilleges and can't run commands as an administrator so you'll need to use sudo to run any administrative commands.</p>
						<p>ls - is the command being ran. ls stands for list storage and lists all files and folders in the current working directory.</p>

						<h2 class="_h2">Commands</h2>
						<p>Most command operate like this:</p>
						<p class="command">command -options arguments</p>
						<div class="container linux_commands">
							<pre class="line-numbers">
							    <code class="language-shell">
								awk # pattern scanning and processing language
								basename # strip directory and suffix from filenames
								bg # resumes suspended jobs without bringing them to the foreground
								cat # print files
								cd # change the shell working directory.
								chmod # change file mode
								chown # change file owner and group
								crontab # maintain crontab files
								curl # transfer a URL
								cut # remove sections from each line of files
								date # display or set date and time
								dig # DNS lookup utility
								df # report file system disk space usage
								diff # compare files line by line
								du # estimate file space usage
								echo # display a line of text
								find # search for files in a directory hierarchy
								fg # resumes suspended jobs and bring them to the foreground
								grep # print lines matching a pattern
								history # lists the previously used commands
								kill # send a signal to a process
								less # read file with pagination
								ln # create links
								ls # list directory contents
								lsb_release # print distribution-specific information
								lsof # list open files
								mkdir # create
								mv # move files
								nc # arbitrary TCP and UDP connections and listens
								netstat # print network connections, routing tables, interface statistics...
								nice # execute a utility with an altered scheduling priority
								nproc # print the number of processing units available
								passwd # change user password
								pgrep # look up processes based on name and other attributes
								pkill # send signal to processes based on name and other attributes
								printenv # print all or part of environment
								pwd # print name of current/working directory
								top # display Linux processes
								tr # translate or delete characters
								ps # report a snapshot of the current processes
								rm # remove files or directories
								rmdir # remove directories
								rsync # remote file copy
								scp # secure copy (remote file copy program)
								sed # stream editor for filtering and transforming text
								sleep # suspend execution for an interval of time
								sort # sort lines of text file
								ssh # OpenSSH SSH client (remote login program)
								ssh-keygen # SSH key generation, management and conversion
								su # substitute user identity. eg. su - cindy
								sudo # execute a command as another user. Usually the super user then exit to go back to not being a super user. So you can read it as super user do.
								tail # output the last part of files
								tar # manipulate archives files
								tr # translate or delete characters
								uname # Print operating system name
								uniq # report or omit repeated lines
								uptime # show how long system has been running
								users # list users logged into the system.
								w # Show who is logged on and what they are doing
								whereis # locate the binary, source, and manual page files for a command
								which # locates a command to find out where the command is or whether it's installed. eg. which cal
								wc # print newline, word, and byte counts for each file
								xargs # build and execute command lines from standard input
								| # redirect standard output to another command
								&gt; # redirect standard output
								&lt; # redirect standard input
								&amp; # send process to background
							    </code>
							</pre>
						</div>

						<h2 class="_h2">Shortcuts</h2>
						<div class="container linux_commands">
							<pre class="line-numbers">
								<code class="language-shell">
									CTRL+A # go to beginning of line
									CTRL+B # moves backward one character
									CTRL+C # stops the current command
									CTRL+D # deletes one character backward or logs out of current session
									CTRL+E # go to end of line
									CTRL+F # moves forward one character
									CTRL+G # aborts the current editing command and ring the terminal bell
									CTRL+K # deletes (kill) forward to end of line
									CTRL+L # clears screen and redisplay the line
									CTRL+N # next line in command history
									CTRL+R # searches in your command history
									CTRL+T # transposes two characters
									CTRL+U # kills backward to the beginning of line
									CTRL+W # kills the word behind the cursor
									CTRL+Y # retrieves last deleted string
									CTRL+Z # stops the current command, resume with fg in the foreground or bg in the background
								</code>
							</pre>
						</div>

						<h2 class="_h2">Terminal</h2>
						<div class="container Terminal">
							<p>the terminal is a program called a terminal emulator that opens a window and lets you interact with the shell.</p>
              <p>terminal emulators we can use (Some Linux distributions install several) include:</p>
              <ul>
                <li>gnome-terminal</li>
                <li>konsole</li>
                <li>xterm</li>
                <li>rxvt</li>
                <li>kvt</li>
                <li>nxterm</li>
                <li>eterm</li>
              </ul>
              <p>While there are a number of different terminal emulators, they all do the same thing. They give us access to a shell session.</p>
              <p>on being launched, the first thing we should see is a shell prompt that contains: user name and the name of the machine followed by a dollar sign.</p>
						</div>						
					</div>
				</section>

				<section class="container" id="file_system_organization">
					<h1 class="_h1">File System Organization</h1>
					<div class="container">
						<p>Like Windows, files on a Linux system are arranged in a hierachical directory structure.</p>
						<p>This means they are organized in a tree-like pattern of directories (called folders in other systems like windows), which may contain files and subdirectories.</p>
						<p>The first directory in the file system is called the root directory. Because the files are arranged in a tree-like pattern which is like an upside down tree so we'd start from the root.</p>
						<p>The root directory contains all files and subdirectories, which contain more files and subdirectories and so on.</p>
						<p>One important difference between Windows and Unix-like Operating Systems such as Linux is that Linux does not employ the concept of drive letters.</p>
						<p>While Windows drive letters split the file system into a series of different trees (one for each device), Linux always has a single tree.</p>
						<p>Different storage devices may be different branches of the tree, but there is always a single tree.</p>
						<p class="note_better">Many features of Linux are controlled by text configuration files and shell scripts.</p>

						<h2 class="_h2">Facts about file names</h2>
						<p>File names that begin with a period character are hidden. This only means that ls will not list them unless we say ls -a. When your account was created, several hidden files were placed in your home directory to configure things for your account. In addition, some applications will place their configuration and settings files in your home directory as hidden files.</p>
						<p>File names in Linux, like Unix, are case sensitive. The file names "File1" and "file1" refer to different files.</p>
						<p>Linux has no concept of a "file extension" like Windows systems. You may name files any way you like. However, while Linux itself does not care about file extensions, many application programs do.</p>
						<p>Though Linux supports long file names which may contain embedded spaces and punctuation characters, limit the punctuation characters to period, dash, and underscore. Most importantly, do not embed spaces in file names. If you want to represent spaces between words in a file name, use underscore characters.</p>

						<h2 class="_h2">Long format for files</h2>
						<p>when we use the command <code>ls -l</code>, it list files in long format.</p>
						<p>The file listing contains a wealth of information about the files being listed.</p>
						<p>Example:</p>
						<p>-rw-rw-r-- 1 me me 276480 Feb 11 20:41 web_site.tar</p>
						<p>drwxr-xr-x 6 me me 1024 Oct 9 2019 web_page</p>
						<p>In order from the right, this can be interpreted as:</p>
						<p><i>File Name</i> - name of the file or directory.</p>
						<p><i>Modification Time</i> - last time the file was modified. If last modification occured more than six months in the past, the date and year are displayed. Otherwise, the time of day is shown.</p>
						<p><i>Size</i> - size of the file in bytes.</p>
						<p><i>Group</i> - name of the group that has file permissions in addition to the file's owner.</p>
						<p><i>Owner</i> - name of the use who owns the file.</p>
						<p><i>File Permissions</i> - a representation of the file's access permissions. The first character is the type of file. A "-" indicates a regular (ordinary) file. A "d" indicates a directory. The second set of three characters represent the read, write and execution rights of the file's owner. The next three represent the rights of the file's group, and the final three the rights granted to everybody else.</p>
						<p>File permissions can be represented using numbers (bits that represent a specific permission). Permissions are usually arranged in order of: User, Group, Everyone else.</p>
						<p>In this case, there is 7bits in 1 byte. each bit represents a permission (read -> 4bits, write -> 2bits, execute ->1bit - totalling to 7 bits).</p>
						<p>Assume we wanted to change the file permissions for a file named file1, where we want the user only to have execute permission. Two ways we would do this are.</p>
						<p>using the symbols</p>
						<p class="command">chmod u+x file1</p>
						<p>using the bits</p>
						<p class="command">chmod 700 file1</p>

						<h2 class="_h2">Text Files</h2>
						<p>There's many ways to represent information in a computer.</p>
						<p>All methods involve defining a relationship between the information and some numbers that will be used to represent it. Computers after all only understand numbers and all data is converted to numeric representation.</p>
						<p>Some of the representation systems are complex (such as compressed multimedia files), while others are rather simple.</p>
						<p>One of the earliest and simplest is called ASCII text. ASCII (pronounced "As-Key") is short for American Standard Code for Information Interchange. This is a simple encoding scheme that was first used on Teletype machines to map keyboard characters to numbers.</p>
						<p>Text is a simple one-to-one mapping of characters to numbers. It is very compact.</p>
						<p>Fifty characters of text translates to fifty bytes of data.</p>
						<p>Throughout a Linux system, many files are stored in text format and there are many Linux tools that work with text files.</p>
						<p>Even Windows systems recognize the importance of this format. The well-known NOTEPAD.EXE program is an editor for plain ASCII text files.</p>
					</div>
				</section>

				<section class="container" id="navigation">
					<h1 class="_h1">Navigation</h1>
					<div class="container">
						<h2 class="_h2">pwd</h2>
						<p>stands for present working directory.</p>
						<p>used to display the current path of your current working directory.</p>
						<p>The working directory is the directory you're currently in.</p>
						<p>When we first log on to a Linux system, the working directory is set to our home directory. This is where we put our files.</p>
						<p>On most systems, the home directory will be called /home/user_name, but it can be anything according to the whims of the system administrator.</p>
						<p class="command">pwd</p>

						<h2 class="_h2">ls</h2>
						<p>Stands for list storage.</p>
						<p>used to list the contents (files and directories) of the current working directory.</p>
						<p class="command">ls</p>
						<p>Options that can be used with ls include:</p>
						<p>to list files in the working directory in long format:</p>
						<p class="command">ls -l</p>
						<p>to list files in two different directories in long format:</p>
						<p class="command">ls -l /etc /bin</p>
						<p>to list all files including hidden files:</p>
						<p class="command">ls -a</p>
						<p>to list all file including hidden files using the long format:</p>
						<p class="command">ls -la</p>

						<h2 class="_h2">cd</h2>
						<p>stands for change directory.</p>
						<p>used to change the working directory.</p>
						<p>used together with the pathname of the desired working directory.</p>
						<p>A pathname is the route we take along the branches of the tree to get to the directory we want.</p>
						<p>Pathnames can be specified in two ways: absolute pathnames and relative pathnames.</p>
						<p><span class="note">Absolute pathname</span> begins with the root directory and follows the tree branch by branch until the path to the desired directory or file is completed.</p>
						<p class="command">cd /usr/bin</p>
						<p><span class="note">Relative pathname</span> starts from the working directory while absolute pathname begins with the root directory.</p>
						<p>To do this, it used special notations to represent relative positions in the file system tree.</p>
						<p>These notations are (.) and (..)</p>
						<p>(.) notations refers to the working directory itself and the (..) notation refers to the working directory's parent directory.</p>
						<p class="command">cd ..</p>
						<p>the command <code>cd</code> followed by nothing will change the working directory to our home directory which is the same as typing <code>cd ~</code>.</p>
						<p>to change the working directory to the home directory of the specified user, use:</p>
						<p class="command">cd ~user_name</p>
						<p>to change the working directory to the home directory of root.</p>
						<p class="command">cd /</p>
						<p>to change the working directory to the previous one, use:</p>
						<p class="command">cd -</p>

						<h2 class="_h2">pushd & popd</h2>
						<p>these commands are used to jump back and forth between two different directories.</p>
						<p>For example, assume we are in the downloads directory but we want to jump into the etc directory for a minute then back into the downloads directory, for that we would pushd into the etc directory then popd right back into the downloads directory.</p>
						<p>to temporarily go and work on the etc directory,</p>
						<p class="command">pushd /etc</p>
						<p>to go back to the previous directory (in our case the downloads directory)</p>
						<p class="command">popd</p>

						<h2 class="_h2">less</h2>
						<p>used to view text files.</p>
						<p>This is very handy since many files used to control and configure linux are human readable.</p>
						<p class="command">less text_file</p>
						<p>less displays the text file one page at a time.</p>
						<p>controls after opening a file using less include:</p>
						<p>page up or b - scroll back one page.</p>
						<p>page down or space - scroll forward one page.</p>
						<p>G - go to end of the text file.</p>
						<p>1G - go to beginning of the text file.</p>
						<p>/characters - search forward in the text file for an occurence of the specified characters.</p>
						<p>n - repeat the previous search.</p>
						<p>h - display a complete list less commands and options.</p>
						<p>q - to exit less.</p>

						<h2 class="_h2">file</h2>
						<p>used to examine a file and tell us what kind of file it is.</p>
						<p class="command">file file_name</p>
						<p>file program recognizes file types such as:</p>
						<ul>
							<li>ASCII text </li>
							<li>Bourne-Again Shell Script text - A bash script.</li>
							<li>ELF 64-bit LSB executable - executable binary program.</li>
							<li>ELF 64-bit LBS shared object - A shared library.</li>
							<li>GNU tar archive - a tape archive file. A common way of storing groups of files.</li>
							<li>gzip compressed data - an archive compressed with gzip.</li>
							<li>HTM document text - web page</li>
							<li>JPEG image data - a compressed JPEG image.</li>
							<li>PostScript document text - A postscript file.</li>
							<li>Zip archive data - an archive compressed with zip.</li>
						</ul>

						<h2 class="_h2">locate</h2>
						<p>used to locate a file by its file name.</p>
						<p>The command uses a database to locate things so for it to be useful, you might want to start by updating that database. The linux system updates the database daily but you can issue the command to update the database yourself.</p>
						<p>to update the database we would use the command</p>
						<p class="command">updatedb</p>
						<p>For example, to locate a file by the name fstab, we would use the command</p>
						<p class="command">locate fstab</p>

            <h2 class="_h2">find</h2>                    
            <p>used to search the system for a file or dir in the working dir or another dir if specified.</p>
            <p>To search for a file in the working dir:</p>
            <p class="command">find . -name a.txt</p>                    
            <p>Search for a file in the working dir using pattern matching:</p>
           	<p>when using pattern matching, the condition must be enclosed in quotes.</p>
            <p class="command">find . -name "*.txt"</p>                    
            <p>To not consider case (lower or uppercase):</p>
            <p class="command">find . -iname A.txt</p>                    
            <p>Finding a dir:</p>
            <p>d in the command stands for type directory.</p>
            <p class="command">find . -type d -name dir_name</p>            
					</div>
				</section>

				<section class="container" id="manipulating_files">
					<h1 class="_h1">Manipulating Files</h1>
					<div class="container">
						<p>Even with a graphical file manager, it's much better to use the command line program to manipulate files because of power and flexibility.</p>
						<p>Complicated tasks can be easier with the command line programs unlike the graphical file manager.</p>
						<p>For example: To copy all the HTML files from one directory to another, but only copy files that did not exist in the destination directory or were newer than the versions in the destination directory?</p>
						<p class="command">cp -u *.html destination</p>

						<h2 class="_h2">Wildcards</h2>
						<p>The shell feature that makes commands so powerful is special characters called wildcards.</p>
						<p>Wildcards help to rapidly specify groups of filenames.</p>
						<p>List of wildcards:</p>
						<ul>
							<li>* - matches any characters.</li>
							<li>? - matches any single character.</li>
							<li>[characters] - matches any character that is a member of the set characters. The set of characters may also be expressed as a POSIX character class such as:
								<ul>
									<li>[:almun:] - alphanumeric characters.</li>
									<li>[:alpha:] - alphabetic characters.</li>
									<li>[:digit:] - numerals.</li>
									<li>[:upper:] - uppercase alphabetic characters.</li>
									<li>[:lower:] - lowercase alphabetic characters.</li>
								</ul>
							</li>
							<li>[!characters] - matches any character that is not a member of the set characters.</li>
						</ul>
						<p>Examples of patterns and what they match:</p>
						<ul>
							<li>* - all filenames.</li>
							<li>g* - all filenames that begin with the character "g".</li>
							<li>b*.txt - all filenames that begin with the character "b" and end with the characters ".txt".</li>
							<li>Data??? - any filename that begins with the characters "Data" followed by exactly 3 more characters.</li>
							<li>[abc]* - any filename that begins with "a" or "b" or "c" followed by any other characters.</li>
							<li>[[:upper:]]* - any filename that begins with an uppercase letter. This is an example of a character class.</li>
							<li>*[![:lower:]] - any filename that does not end with a lowercase letter.</li>
						</ul>

						<h2 class="_h2">touch</h2>
						<p>creates a new file</p>
						<p>To create one file,</p>
						<p class="command">touch file_name</p>
						<p>To create multiple files,</p>
						<p class="command">touch file1 file2 file3 file4 file5 file...</p>

						<h2 class="_h2">cat</h2>
						<p>can be used to view the contents of a file.</p>
						<p>To view the contents of a file named foo.txt, we would use</p>
						<p class="command">cat foo.txt</p>
						<p>cat can also be used to add contents to a file.</p>
						<p>For example to add / append the statement 'Hi, I'm root.' to a file named file1, we would use</p>
						<p class="command">cat >> file1</p>
						<p>this would prompt us to enter some text, in our case 'Hi, I'm root.', then we will use ctrl+D to tell cat command we're done typing.</p>
						<p>to overwrite the contents of file1 we'd use</p>
						<p class="command">cat > file1</p>

						<h2 class="_h2">echo</h2>
						<p>can be used to write text into a file.</p>
						<p>when combined with > and >>, we can either overwrite or append text to a file.</p>
						<p>to write text into a file named foo.txt, we would use</p>
						<p class="command">echo 'this overwrites any text in the file' > foo.txt</p>
						<p>to append some text on a new line into the file named foo.txt, we would use</p>
						<p class="command">echo 'this will be appended on a new line' >> foo.txt</p>

						<h2 class="_h2">wc</h2>
						<p>Used to count the number of lines in a file.</p>
						<p class="command">wc -l file_name</p>

						<h2 class="_h2">cp</h2>
						<p>copies files and directories.</p>
						<p>In its simplest form, it copies a single file.</p>
						<p>to copy contents of file1 into file2. If file2 does not exist, it is created; otherwise silently overwritten with contents of file1.</p>
						<p class="command">cp file1 file2</p>
						<p>to copy contents of file1 into file2 with a prompt (because of the "-i") before overwritting file2 with contents of file1.</p>
						<p class="command">cp -i file1 file2</p>
						<p>to copy the contents of the directory dir1. If directory dir2 does not exist, it is created. Otherwise, it creates a directory named dir1 within directory dir2.</p>
						<p class="command">cp -R dir1 dir2</p>
						<p>Copy all files in the current working directory with names ending with the characters ".txt" to an existing directory named text_files.</p>
						<p class="command">cp *.txt text_files</p>

						<h2 class="_h2">mv</h2>
						<p>moves or renames files and directories.</p>
						<p>It will either move one or more files to a different directory, or it will rename a file or directory.</p>
						<p>To rename a file:</p>
						<p class="command">mv filename1 filename2</p>
						<p>To move files (and / or directories) to a different directory:</p>
						<p class="command">mv file directory</p>
						<p>The files file1 and file2 are moved to directory dir1. If dir1 does not exist, mv will exit with an error.</p>
						<p class="command">mv file1 file2 dir1</p>
						<p>If dir2 does not exist, then dir1 is renamed dir2. If dir2 exists, the directory dir1 is moved within directory dir2.</p>
						<p class="command">mv dir1 dir2</p>
						<p>Move the subdirectory dir1 and all the files ending in ".bak" in the current working directory's parent directory to an existing directory named dir2:</p>
						<p class="command">mv dir1 ..&#47;*.bak dir2</p>

						<h2 class="_h2">rm</h2>
						<p>removes (deletes) files and directories.</p>
						<p>to remove a file</p>
						<p class="command">rm file_name</p>
						<p>we remove directories using the recursive option (-r)</p>
						<p class="command">rm -r directory_name</p>
						<p>we can also use rmdir to remove directories that don't have anything in them</p>
						<p class="command">rmdir directory_name</p>
						<p class="note_better">Linux does not have an undelete command. Once you delete something with rm, it's gone.</p>
						<p>Delete all files in the current working directory that end with the character "~". Some applications create backup files using this naming scheme. Using this command will clean them out of a directory.</p>
						<p class="command">rm *~</p>

						<h2 class="_h2">mkdir</h2>
						<p>used to create directories.</p>
						<p>to create a single directory</p>
						<p class="command">mkdir directory_name</p>
						<p>to create more than one directory</p>
						<p class="command">mkdir directory1 directory2 directory3 directory4 directory...</p>
						<p class="title">To create directories from the parent path (like a parent dir then another dir inside that dir) we use the -p flag.</p>
						<p>If the directories are present, then no error is thrown. If we do not specify ‘-p’ and we try creating directories from parent path, it will thrown an error stating that ‘no such file or directory found’.</p>
						<p>The syntax is: <code>mkdir -p [directories]</code></p>
						<p>For example: To create a directory called first then another directory inside it called second then another inside second called third.</p>
						<p class="command">mkdir -p first/second/third</p>
					</div>
				</section>

				<section class="container" id="permissions">
					<h1 class="_h1">Permissions</h1>
					<div class="container">
						<p>Unix-like Operating Systems, such as LInux differ from other computing systems in that they are not only multitasking but also multi-user.</p>
						<p>This means that more than one user can be operating the computer at the same time.</p>
						<p>While a desktop or laptop computer only has one keyboard and monitor, it can still be used by more than one user.</p>
						<p>For example, if the computer is attached to a network, or the internet, remote uses can log in via ssh (secure shell) and operate the computer. In fact, remote users can execute graphical applications and have the output displayed on a remote computer. The X window system supports this.</p>
						<p>The multi-user capability of Unix-like Operating Systems is  a feature that is deeply ingrained into the design of the OS. If we remember the environment in which Unix was created, this makes perfect sense.</p>
						<p>Years ago before computers were "personal", they were large, expensive and centralized.</p>
						<p>A typical university computer system consisted of a large mainframe computer located throughout the campus, each connected to the large central computer. The computer would support many users at the same time.</p>
						<p>In order to make this practical, a method had to be devised to protect the users from each other. After all, we wouldn't want the actions of one user to crash the computer, nor would we allow one user to interfere with the files belonging to another user.</p>
						<p>Some useful commands to consider include:</p>
						<ul>
							<li><code>chmod</code> - modify the access rights.</li>
							<li><code>su</code> - temporarily become the superuser.</li>
							<li><code>sudo</code> - temporarily become the superuser.</li>
							<li><code>chown</code> - change file ownership.</li>
							<li><code>chgrp</code> - change a file's group ownership.</li>
						</ul>

						<h2 class="_h2">File Permissions</h2>
						<p>On a linux system, each file and directory is assigned access rights for the owner of the file, the members of a group of related users, and everybody else.</p>
						<p>Rights can be assigned to read a file, to write a file, and to execute a file (i.e. run the files as a program).</p>
						<p>To see the permission settings for a file, we can use the <code>ls -l</code> command.</p>
						<p>As a result we would get a result such as:</p>
						<p><code><i>-rwxr-xr-x 1 root root 1113504 Sep 1 2022 /bin/bash</i></code></p>
						<p>We can see that:</p>
						<ul>
							<li>The file /bin/bash is owned by user "root"</li>
							<li>The superuser has the right to read, write and execute this file</li>
							<li>The file is owned by the group "root"</li>
							<li>Members of the group "root" can also read and execute the file</li>
							<li>Everybody else can read and execute this file</li>
						</ul>
						<p>The first portions of the listing is interpreted as:</p>
						<ul>
							<li>- the character indicating the file type. - indicates regular file, d indicates directory.</li>
							<li>rwx - first set (rwx) represents the reding, writing and execution permission for the owner.</li> 
							<li>r-x - Second set (r-x) represents the permissions for the group.</li>
							<li>r-x - Last set (r-x) represents permissions everybody else.</li>
						</ul>

						<h2 class="_h2">chmod</h2>
						<p>The comand is used to change the permissions of a file or directory.</p>
						<p>To use it, we specify the desired permission settings and the file or files that we wish to modify.</p>
						<p>There are two ways to specify the permissions.</p>
						<p>The one used here is called the octal notation method.</p>
						<p>It is easy to think of permission settings as a series of bits (which is how the computer thinks about them). Here's how it works:</p>
						<p><code>rwx rwx rw- = 111 111 110</code></p>
						<ul>
							<li>rwx = 111 in binary = 7</li>
							<li>rw- = 11- in binary = 6</li>
							<li>r-x = 101 in binary = 5</li>
							<li>r-- = 100 in binary = 4</li>
						</ul>
						<p>Now, if we represent each of the three sets of permissions (owner, group and others) as a single digit, we have a pretty convenient way of expressing the possible permission settings.</p>
						<p>For example, to set some_file to have read and write permission for the owner, but wanted to keep the file private from others, we would:</p>
						<p class="command">chmod 600 some_file</p>
						<p>A better way to understand this is that read has 4 bits, write has 2 bits and execute has 1 bit. So the total should be 7 bits which makes up a byte.</p>

						<h2 class="_h2">Directory Permissions</h2>
						<p>The chmod command can also be used to control the access permissions for directories.</p>
						<p>Again, we can use the octal notaion to set permissions, but the meaning of the r, w and x attributes is different.</p>
						<ul>
							<li>r - Allows the contents of the directory to be listed if the x attribute is also set.</li>
							<li></li>
						</ul>
					</div>
				</section>

				<section class="container" id="i_o_redirection">
					<h1 class="_h1">I/O Redirection</h1>
					<div class="container">
						<p>I/O stands for Input / Output.</p>
						<p>Commands such as ls print their output on the display.</p>
						<p>By using some special notations we can redirect the output of many commands to files, devices and even to the input of other commands.</p>

						<h2 class="_h2">Standard Output</h2>
						<p>Most command line programs that display their results do so by sending their results to a facility called standard output.</p>
						<p>By default, standard output directs its contents to the display.</p>
						<p>To redirect standard output to a file, the ">" character is used like:</p>
						<p class="command">ls > file_list.txt</p>
						<p>The ls command is executed and the results are written in a file named file_list.txt.</p>
						<p>Since the output of ls was redirected to the file, no results appear on the display.</p>
						<p class="note_better">> - overwrites contents of the file.</p>
						<p class="note_better">>> - appends contents to a file.</p>
						<p>an example of appending (addin g contents to the end of a file) the ls results to the file file_list.txt is:</p>
						<p class="command">ls >> file_list.txt</p>
						<p>If the file does not exist when we attempt to append the redirected output, the file will be created.</p>

						<h2 class="_h">Standard Input</h2>
						<p>Many commands can accept input from a facility called standard input.</p>
						<p>By default, standard input gets its contents from the keyboard, but like standard output, it can be redirected.</p>
						<p>To redirect standard input from a file instead of the keyboard, the "&lt;" character is used like this:</p>
						<p class="command">sort &lt; file_list.txt</p>
						<p>sort command has been used to process the contents of file_list.txt.</p>
						<p>The results are output on the display since the standard output was not redirected.</p>
						<p>We can redirect standard output to another file like this:</p>
						<p class="command">sort &lt; file_list.txt > sorted_file_list.txt</p>
						<p>A command can have both its input and output redirected.</p>

						<h2 class="_h2">Pipelines</h2>
						<p>The most useful and poweful thing we can do with I/O redirection is to connect multiple commands together to form what are called pipelines.</p>
						<p>With pipelines, the standard output of one command is fed into the standard input of another.</p>
						<p>Example:</p>
						<p class="command">ls -l | less</p>
						<p>The output of ls command is fed into less. By using this "| less" trick, we can make any command have scrolling output.</p>
						<p>Examples  of commands used together with pipelines:</p>
						<p class="command">ls -lt | head</p>
						<p>displays the 10 newest files in the current dir.</p>
						<p class="command">du | sort -nr</p>
						<p>Displays a list of directories and how much space they consume, sorted from the largest to the smallest.</p>
						<p class="command">find . -type f -print | wc -l</p>
						<p>Displays the total number of files in the working directory and all its subdirectories.</p>

						<h2 class="_h2">Filters</h2>
						<p>One kind of program frequently used in pipelines is called a filter.</p>
						<p>Filters take standard input and perform an operation upon it and send the results to standard output.</p>
						<p>In this way, they can be combined to process information in powerful ways.</p>
						<p>Some common programs that act as filters:</p>
						<ul>
							<li>sort - sorts standard input then outputs the sorted result on standard output.</li>
							<li>uniq - given a sorted stream of data from standard input, it removes duplicate lines of data (ie. it makes sure that every line is unique).</li>
							<li>grep - examines each line of data it receives from standard input and outputs every line that contains a specified pattern of characters.</li>
							<li>fmt - reads text from standard input, then outputs formatted text on standard output.</li>
							<li>pr - takes text input from standard input and splits the data into pages with page breaks, headers and footers in preparation for printing.</li>
							<p>head - outputs the first few lines of its input. Useful for getting the header of a file.</p>
							<p>tail - ouputs the last few lines of its input. Useful for things like getting the most recent entries from a log file.</p>
							<p>tr - Translates characters. Can be used to perform tasks such as upper/lowercase convers</p>
						</ul>
					</div>			
				</section>

				<section class="container" id="shell_scripting">
					<h1 class="_h1">Shell Scripting</h1>
					<div class="container">
						<p>Shell scripting is an important part of process automation in Linux. So scripting helps you write a sequence of commands in a file and then execute them.</p>
						<p>This save you time because you don't have to write certain commands again and again. You can perform daily tasks efficiently and even schedule them for automatic execution.</p>
						<p>You can also set certain scripts to execute on startup such as showing particular messages on lauching a new session or setting certain environment variables.</p>

						<h2 class="_h2">Introduction to Bash Shell</h2>
						<p>The Linux command line is provided by a program called the shell.</p>
						<p>Different users can be configured to use different shells. But most users prefer to stick with the current default shell.</p>
						<p>The default shell for most Linux distros is the GNU Bourne-Again Shell (bash). Bash is succeeded by Bourne Shell (sh).</p>
						<p>When you first lauch the shell, it uses a startup script located in the .bashrc or .bash_profile file which allows you to customize the behavior of the shell.</p>
						<p>When a shell is used interactively, it displays a $ when it is waiting for a command from the user. This is called a shell prompt.</p>
						<p>If shell is running as root, the prompt is changed to #.</p>
						<p>Bash is very powerful as it can simplify certain operations that are hard to accomplish efficently with a GUI. Remeber, most servers do not have a GUI, and it is best to learn to use the powers of a Command Line Interface (CLI).</p>

						<h2 class="_h2">What is a bash script?</h2>
						<p>A bash script is a series of commands written in a file. These are read and executed by the bash program. The program executes line by line.</p>
						<p>For example: you can navigate to a certain path, create a folder and spawn a process inside it using the command line.</p>
						<p>You can do the same sequence of steps by saving the commands in a bash script and runnning it. You can run the script any number of times.</p>

						<h2 class="_h2">Identifying a bash script</h2>
						<p class="title">bash scripts have a file extension of <code>sh</code>.</p>
						<p>Bash scripts however can run perfectly fine without the sh extension.</p>
						<p class="title">Scripts that start with a bash bang.</p>
						<p>Scripts are also identified with a <code>shebang</code> which is a combination of <code>bash #</code> and <code>bash !</code> followed by the bash shell path.</p>
						<p>This is usually the first line of the script.</p>
						<p>Shebang tells the shell to execute it via bash shell. Shebang is simply an absolute path to the bash interpreter.</p>
						<p>example of a shebang statement:</p>
						<p class="command">#! /bin/bash</p>
						<p>The path of the bash program can vary.</p>

						<h3 class="_h3">Shebang</h3>
						<div class="container text-center">
							<img src={ hashbang_explained } alt="Hashbang explained" width="50%" height="100%" />
						</div>

						<h2 class="_h2">Execution rights</h2>
						<p>Scripts have execution rights for the user executing them.</p>
						<p>An execution right is represented by x in rwx(read, write, execute).</p>

						<h2 class="_h2">File color</h2>
						<p>Executable scripts appear in a different color from rest of the files and folders.</p>
						<p>Mostly, scripts with execution rights appear green.</p>

						<h2 class="_h2">Creating a bash script</h2>
						<p>To create a simple bash script that outputs Hello, World!</p>
						<p class="command">touch hello_world.sh</p>
						<p class="title">To find the path to your bash shell.</p>
						<p class="command">which bash</p>
						<p>The result should be a file path such as: <code>/usr/bin/bash</code> which should be included in the shebang.</p>
						<p class="title">to echo "Hello World!" to the console, the script for <code>hellow_world.sh</code> would be:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									#! usr/bin/bash
									echo "Hello, World!"
								</code>
							</pre>
						</div>
						<p class="title">provide execution rights to users and allow execution of the script:</p>
						<p class="command">chmod u+x hello_world.sh</p>
						<p>chmod modifies the existing rights of a file for a particular user. We are adding +x to user u.</p>
						<p class="title">Run the script</p>
						<p>This can be done in two ways:</p>
						<ol>
							<li><span class="command">./hello_world.sh</span></li>
							<li><span class="command">bash hello_world.sh</span></li>
						</ol>

						<h2 class="_h2">Basic syntax of shell scripting</h2>
						<p>Like other programming languages, bash scripting follows a set of rules to create programs understandable by the computer.</p>
						<h3 class="_h3">Defining variables</h3>
						<p>define variables by using the syntax, variable_name = value.</p>
						<p>To get the value of the variable, add $ before the variable.</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									#!/bin/bash
									# A simple variable example
									greeting=Hello
									name=Tux
									echo $greeting $name
								</code>
							</pre>
						</div>
						<p>Tux is also the name of the Linux mascot, the penguin.</p>

						<h3 class="_h3">Arithmetic Expressions</h3>
						<p>operations supported by bash for mathematical calculations include:</p>
						<ul>
							<li>+ addition</li>
							<li>- subtraction</li>
							<li>* multiplication</li>
							<li>/ division</li>
							<li>** exponensiation</li>
							<li>% modulus</li>
						</ul>
						<p>A simpe example would be:</p>
						<p class="command">expr 16 / 4</p>
						<p>Numerical expressions can also be calculated and stored in a variable using the syntax:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									var=$((expression))
								</code>
							</pre>
						</div>
						<p>An example would be:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									#!/bin/bash

									var=$((3+9))
									echo $var
								</code>
							</pre>
						</div>
						<p>Fractions are not calculated using the above methods and are truncated.</p>
						<p>For decimal calculations, we can use <code>bc</code> command to get the output to a particular number of decimal places. <code>bc</code> (Bash Calculator) is a command line calculator that supports calculation up to a certain number of decimal points.</p>
						<p class="command">echo "scale=2;22/7" | bc</p>
						<p>Where scale defines the number of decimal places required in the output.</p>

						<h2 class="_h2">Reading user input</h2>
						<p>Sometimes you'll need to gather some input and perform relevant operations.</p>
						<p>In bash, we take user input using the <code>read</code> command.</p>
						<p class="command">read variable_name</p>
						<p>To prompt the user with a custom message, use the -p flag.</p>
						<p class="command">read -p "Enter your age" variable_name</p>
						<p>Example:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									#!/bin/bash

									echo "Enter a number: "
									read a
									
									echo "Enter a number: "
									read b

									var=$((a+b))
									echo $var
								</code>
							</pre>
						</div>

						<h2 class="_h2">Numeric comparison logical operators</h2>
						<p>Comparison is used to check if statements evaluate to true or false.</p>
						<p>Operators we can use include:</p>
						<div class="container">
							<table class="table table-hover text-white">
								<thead>
									<th>Operation</th>
									<th>Syntax</th>
									<th>Explanation</th>
								</thead>
								<tbody>
									<tr>
										<td>Equality</td>
										<td>num1 -eq num2</td>
										<td>is num1 equal to num2</td>
									</tr>
									<tr>
										<td>Greater than equal to</td>
										<td>num1 -ge num2</td>
										<td>is num1 greater than equal to num2</td>
									</tr>
									<tr>
										<td>Greater than</td>
										<td>num1 -gt num2</td>
										<td>is num1 greater than num2</td>
									</tr>
									<tr>
										<td>Less than equal to</td>
										<td>num1 -le num2</td>
										<td>is num1 less than equal to num2</td>
									</tr>
									<tr>
										<td>Less than</td>
										<td>num1 -lt num2</td>
										<td>is num1 less than num2</td>
									</tr>
									<tr>
										<td>Not equal to</td>
										<td>num1 -ne num2</td>
										<td>is num1 not equal to num2</td>
									</tr>
								</tbody>
							</table>
						</div>
						<p>Syntax:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									if [condition]
										then
											commands
									fi
								</code>
							</pre>
						</div>
						<p>Example:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									read x
									read y

									if [ $x -gt $y ]
									then
									echo X is greater than Y
									elif [ $x -lt $y ]
									then
									echo X is less than Y
									elif [ $x -eq $y]
									then
									echo X is equal to Y
									fi
								</code>
							</pre>
						</div>

						<h2 class="_h2">Conditional Statements (Decision Making)</h2>
						<p>Conditions are expressions that evaluate to a boolean expression (true or false). To check conditions, we can use if, if-else, if-elif-else and nested conditionals.</p>
						<p>The structure of conditional statements is:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									if...then...fi statements
									if...then...else...fi statements
									if...elif...else...fi
									if...then...else...if...then...fi...fi... (Nested conditionals)
								</code>
							</pre>
						</div>
						<p>Syntax:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									if [[ condition ]]
									then 
										statement
									elif [[ condition ]]; then
										statement
									else
										do this by default
									fi
								</code>
							</pre>
						</div>
						<p>To create meaningful comparisons, we can use AND -a and OR -o as well.</p>
						<p>This translates to: if a is greater than 4 and b is less that 6:</p>
						<p class="command">if [ $a -gt 40 -a $b -lt 6 ]</p>
						<p>Example: To find the triangle types by reading the lengths of its sides:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									read a
									read b
									read c

									if [ $a == $b -a $b == $c -a $a == $c ]
									then
									echo EQUILATERAL

									elif [ $a == $b -o $b == $c -o $a == $c ]
									then 
									echo ISOSCELES
									else
									echo SCALENE

									fi
								</code>
							</pre>
						</div>

						<h2 class="_h2">Looping and Skipping</h2>
						<h3 class="_h3">For loop</h3>
						<p>For loops allow you to execute statements a specific number of times.</p>
						<p class="title">Looping with numbers</p>
						<p>To iterate 5 times:</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									#!/bin/bash

									for i in &#123;1..5&#125;
									do 
										echo $i
									done
								</code>
							</pre>
						</div>
						<p class="title">Looping through strings</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									#!/bin/bash

									for x in cyan magenta yellow
									do
										echo $x
									done
								</code>
							</pre>
						</div>

						<h3 class="_h3">While loop</h3>
						<p>While loops check for a codition and loop until the condition remains true. We need to provide a counter statement that increments the counter to control loop execution.</p>
						<p>in the example, (( i  += 1 )) is the counter statement that increments the value of i.</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									#!/bin/bash
									i=1
									while [[ $i -le 10 ]] ; do
										echo "$i"
										(( i += 1 ))
									done
								</code>
							</pre>
						</div>

						<h3 class="_h3">Creating a script to change dir</h3>
						<p>To create a script that changes the working directory to another directory (say, the Documents directory):</p>
						<div class="container code">
							<pre class="line-numbers">
								<code class="language-C">
									#!/bin/bash
									cd /home/Documents
									$SHELL
								</code>
							</pre>
						</div>
					</div>					
				</section>

				<section class="container" id="command_line_editors">
					<h1 class="_h1">Command line editors</h1>
					<div class="container">
						<div class="container">
							<h2 class="_h2">Vi</h2>
							<p>vi stands for visual editor.</p>
							<p>vi is the default editor that comes with the UNIX OS.</p>
							<p>both UNIX and vi are case-sensitive.</p>
							<p>vi is a full screen editor and has two modes of operation:</p>
							<ul>
								<li>Command mode - allows you to type commands. To enter into command mode, press <code>Esc + :</code> then type the command.</li>
								<li>Insert mode - allows you to edit the file. To enter into insert mode, type i</li>
							</ul>
							<p>In the command mode, every character typed is a command that does something to the text file being edited; a character typed in the command mode may even cause vi editor to enter the insert mode.</p>
							<p>In the insert mode, every character typed is added to the text in the file; pressing the &lt;Esc&gt; (Escape) key turns off the insert mode.</p>

							<h3 class="_h3">Getting in and out of vi</h3>
							<p class="title">To start vi</p>
							<p>to edit or create a file using vi, use the command:</p>
							<p class="command">vi file_name</p>
							<p>if the file named filename exists, then the first page (or screen) of the file will be displayed; if the file does not exist, then an empty file and screen are created into which you may enter text.</p>
							<p>To recover a filename that was being edited when the system crashed:</p>
							<p class="command">vi -r file_name</p>
							<p class="title">To exit vi</p>
							<p>Usually, the new or modified file is saved when you leave vi.</p>
							<p>However, it is also possible to quit vi without saving the file.</p>
							<p>Note: The cursor moves to the bottom of the screen whenever a colon (:) is typed.</p>
							<p>This type of command is completed by hitting the &lt;Return&gt; key.</p>

							<h3 class="_h3">Showing line numbers</h3>
							<p>command for showing line numbers is:</p>
							<p class="command">:set number</p>
							<p>command for disabling line numbers is:</p>
							<p class="command">:set nonumber</p>
							<p>To permanently enable line numbers, add the command to the <code>vimrc</code> file (/etc/vim/vimrc):</p>
							<p class="command">:set number</p>					
						</div>
						<div class="container">
							<h2 class="_h2">Emacs</h2>
							<p>The <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html">GNU Emacs Manual calls Emacs</a> the extensible, customizable, self-documenting real-time display editor.</p>
							<p>There's a lot you can do with Emacs for example:</p>
							<ul>
								<li>Beyond just being able to edit plain text files, Emacs includes special features to help you write in many different human languages and programming / markup languages.</li>
								<li>as well as tools for compiling, running and testing programs, Emacs integrates with GDB to provide an IDE (M- x gdb):</li>
								<li>Emacs can compare two files and highlight their differences (M-x ediff):</li>
								<li>Emacs is a file manager (M-x dired):</li>
								<li>Emacs can read news, mail and RSS feeds (M-x gnus):</li>
								<li>You can even play tetris in Emacs (M-x tetris):</li>
							</ul>
							<p>Some people consider Emacs to be not merely a text editor but almost a complete Operating System.</p>
							<p>Some people find that they can do almost all of their work from within Emacs.</p>

							<h3 class="_h3">Why Emacs?</h3>
							<p>Emacs helps you be productive by providing an integrated environment for many different kinds of tasks:</p>
							<ul>
								<li>All of the basic editing commands are available no matter what you're trying to do: write code, read a manual, use a shell, or compose an email.</li>
								<li>All the tools Emacs provides for opening, saving, searching and processing text (and more) are available to you no matter what you're doing.</li>
							</ul>
							<p>This uniformity means working within Emacs is often easier than learning to use a separate program, especially when that program is liable to have its own set of editing capabilities and shortcuts.</p>
							<p>You can use the <a href="https://www.gnu.org/software/emacs/manual/elisp.html">Emacs Lisp</a> (Elisp) language to customize Emacs, automate common tasks, or add new features.</p>
							<p>Elisp is very easy to get started with and yet remarkably powerful: you can use it to alter and extend almost any feature of Emacs. You can make Emacs whatever you want it to be by writing Elisp code.</p>
							<p>Emacs is also portable. You can use the same editor (with the same configuration) on many platforms, including GNU/Linux, BSD and other Unix derivatives, and some proprietary operating systems such as Microsoft Windows.</p>
						</div>
					</div>
				</section>

				<section class="container" id="tips">
					<h1 class="_h1">Tips</h1>
					<div class="container">
						<ul>
							<li>Learn redirection.</li>
						</ul>
						<p>To learn more about the OS you're using.</p>
						<p class="command">cat /etc/os-release</p>
						<p>After viewing the history of commands, use ! then id of the command to run it. eg. !23 to run command 23 in the history list of commands.</p>
					</div>
				</section>

				<section class="container" id="links">
					<h1 class="_h1">Links</h1>
					<div class="container">
						<ul>
							<li>Learn linux: <a href="http://linuxcommand.org/" target="_blank" rel="noreferrer">website for linux</a></li>
							<li>To access files from windows using wsl, use the command: <code>cd /mnt/c</code></li>
						</ul>
					</div>
				</section>
                <!-- <p>started learning in June 28, 2022</p> -->
			</main>
		</section>
		<script src="../../_resources/js/prism.js"></script>
	</body>
</html>
